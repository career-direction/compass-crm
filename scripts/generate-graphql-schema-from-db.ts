#!/usr/bin/env npx tsx
/**
 * Drizzle ORMã‚¹ã‚­ãƒ¼ãƒã‹ã‚‰å®Œå…¨ãªGraphQLã‚¹ã‚­ãƒ¼ãƒã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 *
 * Database-Firstã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:
 * 1. Drizzleã‚¹ã‚­ãƒ¼ãƒï¼ˆsrc/db/schema.tsï¼‰ã‚’èª­ã¿è¾¼ã‚€
 * 2. å®Œå…¨ãªGraphQLã‚¹ã‚­ãƒ¼ãƒï¼ˆå‹ + Query + Mutation + Inputï¼‰ã‚’ç”Ÿæˆ
 * 3. schema.graphql ã‚’ä¸Šæ›¸ãï¼ˆã¾ãŸã¯ãƒãƒ¼ã‚¸ï¼‰
 *
 * ä½¿ç”¨æ–¹æ³•:
 *   npm run schema:generate-from-db
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

// Drizzleã®å‹ã‚’GraphQLå‹ã«ãƒãƒƒãƒ”ãƒ³ã‚°
const typeMapping: Record<string, string> = {
	bigserial: "Int!",
	bigint: "Int!",
	integer: "Int!",
	varchar: "String!",
	text: "String!",
	boolean: "Boolean!",
	date: "String!",
	timestamp: "String!",
	uuid: "String!",
};

const nullableTypeMapping: Record<string, string> = {
	bigserial: "Int",
	bigint: "Int",
	integer: "Int",
	varchar: "String",
	text: "String",
	boolean: "Boolean",
	date: "String",
	timestamp: "String",
	uuid: "String",
};

interface ColumnInfo {
	name: string;
	type: string;
	isNotNull: boolean;
	isArray: boolean;
	isPrimary: boolean;
	isAutoGenerated: boolean; // primaryKey() ã‚„ default() ãŒã‚ã‚‹å ´åˆ
}

interface TableInfo {
	name: string;
	graphqlName: string;
	columns: ColumnInfo[];
	foreignKeys: ForeignKeyInfo[];
}

interface ForeignKeyInfo {
	columnName: string;
	referencedTable: string;
	referencedGraphQLType: string;
}

/**
 * ãƒ†ãƒ¼ãƒ–ãƒ«åã‚’GraphQLå‹åã«å¤‰æ›
 */
function toGraphQLTypeName(tableName: string): string {
	// è¤‡æ•°å½¢ã‚’å˜æ•°å½¢ã«å¤‰æ›
	let singular = tableName;
	if (tableName.endsWith("ies")) {
		singular = `${tableName.slice(0, -3)}y`;
	} else if (tableName.endsWith("ses")) {
		singular = tableName.slice(0, -2);
	} else if (tableName.endsWith("s") && !tableName.endsWith("ss")) {
		singular = tableName.slice(0, -1);
	}

	// ã‚­ãƒ£ãƒ¡ãƒ«ã‚±ãƒ¼ã‚¹ã‚’ãƒ‘ã‚¹ã‚«ãƒ«ã‚±ãƒ¼ã‚¹ã«å¤‰æ›
	const parts = singular.split(/(?=[A-Z])/);
	let result = parts
		.map((part) => part.charAt(0).toUpperCase() + part.slice(1))
		.join("");

	// ç‰¹æ®Šã‚±ãƒ¼ã‚¹ã®ä¿®æ­£
	if (result === "MidtermHealthPurpos") {
		result = "MidtermHealthPurpose";
	}
	if (result === "PtSession") {
		result = "PTSession";
	}
	if (result === "PtSessionItem") {
		result = "PTSessionItem";
	}

	return result;
}

/**
 * ãƒ†ãƒ¼ãƒ–ãƒ«åã‚’GraphQL Queryåã«å¤‰æ›ï¼ˆcamelCaseï¼‰
 */
function toGraphQLQueryName(tableName: string): string {
	// ã‚­ãƒ£ãƒ¡ãƒ«ã‚±ãƒ¼ã‚¹ã‚’ç¶­æŒ
	return tableName.charAt(0).toLowerCase() + tableName.slice(1);
}

/**
 * å¤–éƒ¨ã‚­ãƒ¼ã‚’æ¤œå‡º
 */
function detectForeignKeys(
	tableName: string,
	columns: ColumnInfo[],
	allTables: string[],
): ForeignKeyInfo[] {
	const foreignKeys: ForeignKeyInfo[] = [];

	for (const column of columns) {
		// ã‚«ãƒ©ãƒ åã‹ã‚‰å¤–éƒ¨ã‚­ãƒ¼ã‚’æ¨æ¸¬
		// ä¾‹: clientId -> clients, userId -> users, ptSessionId -> ptSessions
		const match = column.name.match(/^(.+?)(Id|_id)$/i);
		if (match) {
			const baseName = match[1];
			// è¤‡æ•°å½¢ã«å¤‰æ›
			let pluralName = baseName;
			if (!pluralName.endsWith("s")) {
				if (pluralName.endsWith("y")) {
					pluralName = `${pluralName.slice(0, -1)}ies`;
				} else {
					pluralName = `${pluralName}s`;
				}
			}

			// ãƒ†ãƒ¼ãƒ–ãƒ«åã®å€™è£œã‚’æ¢ã™
			const candidateTable = allTables.find(
				(t) =>
					t.toLowerCase() === pluralName.toLowerCase() ||
					t.toLowerCase() === baseName.toLowerCase(),
			);

			if (candidateTable) {
				foreignKeys.push({
					columnName: column.name,
					referencedTable: candidateTable,
					referencedGraphQLType: toGraphQLTypeName(candidateTable),
				});
			}
		}
	}

	return foreignKeys;
}

/**
 * ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‘ãƒ¼ã‚¹
 */
function parseSchemaFile(schemaContent: string): TableInfo[] {
	const tables: TableInfo[] = [];

	const tableRegex =
		/export const (\w+) = pgTable\("(\w+)",\s*\{([\s\S]*?)\}\);/g;

	const tableMatches = Array.from(schemaContent.matchAll(tableRegex));
	const tableNames = tableMatches.map((m) => m[1]);

	for (const match of tableMatches) {
		const [, variableName, , columnsBlock] = match;
		const columns: ColumnInfo[] = [];

		const columnStarts: number[] = [];
		const colStartRegex = /^\s*(\w+):\s*\w+\(/gm;

		for (const colStartMatch of columnsBlock.matchAll(colStartRegex)) {
			columnStarts.push(colStartMatch.index ?? 0);
		}

		for (let i = 0; i < columnStarts.length; i++) {
			const start = columnStarts[i];
			const end = columnStarts[i + 1] ?? columnsBlock.length;
			const colDef = columnsBlock.slice(start, end);

			const colMatch = colDef.match(/^\s*(\w+):\s*(\w+)\(/);

			if (colMatch) {
				const [, colName, colType] = colMatch;

				const isNotNull =
					colDef.includes(".notNull()") || colDef.includes(".primaryKey()");
				const isArray = colDef.includes(".array()");
				const isPrimary = colDef.includes(".primaryKey()");
				const isAutoGenerated =
					isPrimary ||
					colDef.includes(".default(") ||
					colDef.includes(".defaultNow()");

				columns.push({
					name: colName,
					type: colType,
					isNotNull,
					isArray,
					isPrimary,
					isAutoGenerated,
				});
			}
		}

		const foreignKeys = detectForeignKeys(variableName, columns, tableNames);

		tables.push({
			name: variableName,
			graphqlName: toGraphQLTypeName(variableName),
			columns,
			foreignKeys,
		});
	}

	return tables;
}

/**
 * GraphQLå‹ã‚’å–å¾—
 */
function getGraphQLType(column: ColumnInfo): string {
	const baseType = column.isNotNull
		? typeMapping[column.type] || "String!"
		: nullableTypeMapping[column.type] || "String";

	if (column.isArray) {
		const innerType = baseType.replace("!", "");
		return column.isNotNull ? `[${innerType}!]!` : `[${innerType}!]`;
	}

	return baseType;
}

/**
 * é™¤å¤–ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®šç¾©
 * ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã§ä¸Šæ›¸ãã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’é™¤å¤–
 */
const EXCLUDED_FIELDS: Record<string, Set<string>> = {
	BodyCondition: new Set([
		"weight",
		"bodyFat",
		"muscleMass",
		"skeletalMuscleRate",
		"bmi",
		"bmr",
		"avgSleepTime",
		"avgRespirationRate",
		"sympathetic",
		"parasympathetic",
		"bust",
		"underbust",
		"waist",
		"hip",
		"armCircumference",
		"buttockHeight",
		"thighCircumference",
		"calfCircumference",
		"ffd",
		"hwd",
	]),
	TrainerProfile: new Set([
		"signatureMuscle", // â†’ signatureMuscles ã¨ã—ã¦ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§å®šç¾©
		"specialization", // â†’ specializations ã¨ã—ã¦ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§å®šç¾©
	]),
};

/**
 * GraphQLå‹å®šç¾©ã‚’ç”Ÿæˆ
 */
function generateGraphQLType(table: TableInfo): string {
	const fields: string[] = [];
	const excludedFields = EXCLUDED_FIELDS[table.graphqlName] || new Set();

	// åŸºæœ¬ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿ç”Ÿæˆ
	// ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ custom-fields.graphql ã§å®šç¾©ã™ã‚‹
	for (const col of table.columns) {
		// é™¤å¤–ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã‚¹ã‚­ãƒƒãƒ—
		if (excludedFields.has(col.name)) {
			continue;
		}

		const graphqlType = getGraphQLType(col);
		fields.push(`\t${col.name}: ${graphqlType}`);
	}

	return `type ${table.graphqlName} {\n${fields.join("\n")}\n}`;
}

/**
 * ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å®šç¾©ã•ã‚Œã¦ã„ã‚‹Queryåã‚’æŠ½å‡º
 */
function extractCustomQueryNames(customFieldsContent: string): Set<string> {
	const customQueries = new Set<string>();
	const queryRegex = /extend type Query \{([\s\S]*?)\}/;
	const match = customFieldsContent.match(queryRegex);
	if (match) {
		const queryBlock = match[1];
		const fieldRegex = /^\s*(\w+)\s*\(/gm;
		for (const fieldMatch of queryBlock.matchAll(fieldRegex)) {
			customQueries.add(fieldMatch[1]);
		}
	}
	return customQueries;
}

/**
 * Queryå‹ã‚’ç”Ÿæˆ
 */
function generateQueryType(
	tables: TableInfo[],
	customQueryNames: Set<string> = new Set(),
): string {
	const queries: string[] = [];

	// å„ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾ã—ã¦Queryã‚’ç”Ÿæˆ
	for (const table of tables) {
		const queryName = toGraphQLQueryName(table.name);
		const typeName = table.graphqlName;

		// ã‚«ã‚¹ã‚¿ãƒ QueryãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
		if (customQueryNames.has(queryName)) {
			continue;
		}

		// ä¸€è¦§å–å¾—
		queries.push(
			`\t${queryName}(limit: Int, offset: Int): [${typeName}!]!`,
		);

		// IDã§å–å¾—ï¼ˆä¸»ã‚­ãƒ¼ãŒã‚ã‚‹å ´åˆï¼‰
		const primaryKey = table.columns.find((c) => c.isPrimary);
		if (primaryKey) {
			const byIdQueryName = `${queryName}ById`;
			if (!customQueryNames.has(byIdQueryName)) {
				queries.push(
					`\t${byIdQueryName}(${primaryKey.name}: Int!): ${typeName}`,
				);
			}
		}
	}

	return `type Query {\n${queries.join("\n")}\n}`;
}

/**
 * Mutationå‹ã‚’ç”Ÿæˆ
 */
function generateMutationType(tables: TableInfo[]): string {
	const mutations: string[] = [];

	for (const table of tables) {
		const tableName = table.name.toLowerCase();
		const typeName = table.graphqlName;
		const inputName = `Create${table.graphqlName}Input`;

		// Create Mutation
		mutations.push(
			`\tcreate${table.graphqlName}(input: ${inputName}!): ${typeName}!`,
		);
	}

	return `type Mutation {\n${mutations.join("\n")}\n}`;
}

/**
 * ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å®šç¾©ã•ã‚Œã¦ã„ã‚‹Inputå‹åã‚’æŠ½å‡º
 */
function extractCustomInputNames(customFieldsContent: string): Set<string> {
	const customInputs = new Set<string>();
	const inputRegex = /^input (Create\w+Input)/gm;
	for (const match of customFieldsContent.matchAll(inputRegex)) {
		customInputs.add(match[1]);
	}
	return customInputs;
}

/**
 * Inputå‹ã‚’ç”Ÿæˆ
 */
function generateInputType(
	table: TableInfo,
	customInputNames: Set<string> = new Set(),
): string {
	// ã‚«ã‚¹ã‚¿ãƒ Inputå‹ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
	const inputName = `Create${table.graphqlName}Input`;
	if (customInputNames.has(inputName)) {
		return "";
	}

	const fields: string[] = [];

	for (const col of table.columns) {
		// è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯é™¤å¤–
		if (col.isAutoGenerated && col.isPrimary) {
			continue;
		}

		// default()ãŒã‚ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯é™¤å¤–ï¼ˆè‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ï¼‰
		// ãŸã ã—ã€notNull()ã§ãªã„å ´åˆã¯å«ã‚ã‚‹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼‰
		if (col.isAutoGenerated && col.isNotNull) {
			continue;
		}

		// createdAt, updatedAtã¯é™¤å¤–ï¼ˆè‡ªå‹•è¨­å®šï¼‰
		if (col.name === "createdAt" || col.name === "updatedAt") {
			continue;
		}

		// keyãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯UUIDã§è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ãŸã‚é™¤å¤–
		if (col.name === "key" && col.type === "uuid") {
			continue;
		}

		const graphqlType = getGraphQLType(col);
		fields.push(`\t${col.name}: ${graphqlType}`);
	}

	if (fields.length === 0) {
		return "";
	}

	return `input ${inputName} {\n${fields.join("\n")}\n}`;
}

/**
 * ãƒ¡ã‚¤ãƒ³å‡¦ç†
 */
async function main() {
	const __filename = fileURLToPath(import.meta.url);
	const __dirname = path.dirname(__filename);
	const projectRoot = path.resolve(__dirname, "..");
	const schemaPath = path.join(projectRoot, "src/db/schema.ts");
	const customFieldsPath = path.join(
		projectRoot,
		"src/lib/graphql/schema/custom-fields.graphql",
	);
	const outputPath = path.join(
		projectRoot,
		"src/lib/graphql/schema/schema.graphql",
	);

	console.log("ğŸ“– Drizzleã‚¹ã‚­ãƒ¼ãƒã‚’èª­ã¿è¾¼ã¿ä¸­...");
	const schemaContent = fs.readFileSync(schemaPath, "utf-8");

	console.log("ğŸ” ãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©ã‚’ãƒ‘ãƒ¼ã‚¹ä¸­...");
	const tables = parseSchemaFile(schemaContent);

	console.log(`ğŸ“‹ ${tables.length}å€‹ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ¤œå‡ºã—ã¾ã—ãŸ`);
	for (const table of tables) {
		console.log(
			`   - ${table.name} -> ${table.graphqlName} (å¤–éƒ¨ã‚­ãƒ¼: ${table.foreignKeys.length}å€‹)`,
		);
	}

	// ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰Queryåã¨Inputå‹åã‚’æŠ½å‡º
	let customQueryNames = new Set<string>();
	let customInputNames = new Set<string>();
	if (fs.existsSync(customFieldsPath)) {
		const customFieldsContent = fs.readFileSync(customFieldsPath, "utf-8");
		customQueryNames = extractCustomQueryNames(customFieldsContent);
		customInputNames = extractCustomInputNames(customFieldsContent);
		console.log(
			`ğŸ” ã‚«ã‚¹ã‚¿ãƒ Query ${customQueryNames.size}å€‹ã‚’æ¤œå‡º: ${Array.from(customQueryNames).join(", ")}`,
		);
		console.log(
			`ğŸ” ã‚«ã‚¹ã‚¿ãƒ Inputå‹ ${customInputNames.size}å€‹ã‚’æ¤œå‡º: ${Array.from(customInputNames).join(", ")}`,
		);
	}

	// GraphQLã‚¹ã‚­ãƒ¼ãƒã‚’ç”Ÿæˆ
	const header = `# ============================================
# è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸGraphQLã‚¹ã‚­ãƒ¼ãƒ
# ç”Ÿæˆå…ƒ: src/db/schema.ts (Drizzle ORM)
#
# Database-Firstã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:
# - Drizzleã‚¹ã‚­ãƒ¼ãƒãŒSingle Source of Truth
# - ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ãŸã‚ã€æ‰‹å‹•ç·¨é›†ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“
# - ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå¿…è¦ãªå ´åˆã¯ã€scripts/generate-graphql-schema-from-db.ts ã‚’ç·¨é›†ã—ã¦ãã ã•ã„
#
# ç”Ÿæˆæ—¥æ™‚: ${new Date().toISOString()}
# ============================================

`;

	// Queryå‹
	const queryType = generateQueryType(tables, customQueryNames);

	// Mutationå‹
	const mutationType = generateMutationType(tables);

	// å‹å®šç¾©
	const types = tables.map(generateGraphQLType).join("\n\n");

	// Inputå‹
	const inputTypes = tables
		.map((table) => generateInputType(table, customInputNames))
		.filter((input) => input !== "")
		.join("\n\n");

	const output =
		header +
		queryType +
		"\n\n" +
		mutationType +
		"\n\n" +
		types +
		"\n\n" +
		inputTypes;

	// ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒãƒ¼ã‚¸
	let finalOutput = output;
	if (fs.existsSync(customFieldsPath)) {
		console.log("ğŸ”— ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒãƒ¼ã‚¸ä¸­...");
		const customFields = fs.readFileSync(customFieldsPath, "utf-8");
		finalOutput = output + "\n\n" + customFields;
	} else {
		console.log("â„¹ï¸  ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰");
	}

	console.log("ğŸ“ GraphQLã‚¹ã‚­ãƒ¼ãƒã‚’æ›¸ãå‡ºã—ä¸­...");
	fs.writeFileSync(outputPath, finalOutput);

	console.log(`âœ… å®Œäº†: ${outputPath}`);
	console.log("");
	console.log("ğŸ“Œ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:");
	console.log("   1. ç”Ÿæˆã•ã‚ŒãŸã‚¹ã‚­ãƒ¼ãƒã‚’ç¢ºèªã—ã¦ãã ã•ã„");
	console.log("   2. npm run codegen ã‚’å®Ÿè¡Œã—ã¦å‹ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„");
	console.log("   3. å¿…è¦ã«å¿œã˜ã¦ãƒªã‚¾ãƒ«ãƒãƒ¼ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„");
}

main().catch(console.error);

